# Algorithmie

![Glider](assets/image/Game_of_life_animated_glider.gif)

### Formation

---
## Principes generaux

- Un algorithme est une suite finie et non ambiguë d’opérations ou d'instructions permettant de résoudre un problème ou d'obtenir un résultat |
- Un problème est un objet mathématique qui représente une question ou un ensemble de questions auxquelles un ordinateur devrait être en mesure de répondre. |

---
- L'algorithmique est l'étude et la production de règles et techniques qui sont impliquées dans la définition et la conception d'algorithmes,
- c'est-à-dire de processus systématiques de résolution d'un problème permettant de décrire précisément des étapes pour résoudre un problème algorithmique. |
- Un algorithme prend des données en entrées et calcule des données en retour |

---

## Antiquité

- Les premiers algorithmes dont on a retrouvé des descriptions datent des Babyloniens, au IIIe millénaire av. J.-C.. Ils décrivent des méthodes de calcul et des résolutions d'équations à l'aide d'exemples. |
- Un algorithme célèbre est celui qui se trouve dans le livre 7 des Éléments d'Euclide, et appelé algorithme d'Euclide. Il permet de trouver le plus grand diviseur commun, ou PGCD, de deux nombres. |

---
C'est Archimède qui proposa le premier un algorithme pour le calcul de $$π^2$$

---
## Étude systématique

- Le premier à avoir systématisé des algorithmes est le mathématicien perse Al-Khwârizmî, actif entre 813 et 833. |
- Dans son ouvrage Abrégé du calcul par la restauration et la comparaison, il étudie toutes les équations du second degré et en donne la résolution par des algorithmes généraux. |

---

- Il utilise des méthodes semblables à celles des Babyloniens, mais se différencie par ses explications systématiques là où les Babyloniens donnaient seulement des exemples.
- Le mot algorithme vient du nom du mathématicien Al-Khwârizmî (latinisé au Moyen Âge en Algoritmi), qui, au IXe siècle écrivit le premier ouvrage systématique donnant des solutions aux équations linéaires et quadratiques. Algorithme a donné algorithmique auxquels certains préfèrent le néologisme algorithmie. |

---

Le savant andalou Averroès (1126-1198) évoque une méthode de raisonnement où la thèse s’affine étape par étape, itérativement, jusqu’à une certaine convergence et ceci conformément au déroulement d’un algorithme. À la même époque, au XIIe siècle, le moine Adelard de Bath introduit le terme latin de algorismus, par référence au nom de Al Khuwarizmi. Ce mot donne algorithme en français en 1554.

---

- Au XVIIe siècle, on pourrait entrevoir une certaine allusion à la méthode algorithmique chez René Descartes dans la méthode générale proposée par le Discours de la méthode (1637), notamment quand, en sa deuxième partie, le mathématicien français propose
- « diviser chacune des difficultés que j’examinerois, en autant de parcelles qu’il se pourroit, et qu’il seroit requis pour les mieux résoudre. » |

---
- Sans évoquer explicitement les concepts de boucle, d’itération ou de dichotomie, l’approche de Descartes prédispose la logique à accueillir le concept de programme, mot qui naît en français en 1677.
- En 1843 , la mathématicienne et pionnière des sciences informatique Ada Lovelace, fille de Lord Byron et assistante de Charles Babbage réalise la première implémentation d'un algorithme sous forme de programme (calcul des nombres de Bernoullii) |
---

Le dixième problème de Hilbert qui fait partie de la liste des 23 problèmes posés par David Hilbert en 1900 à Paris est clairement un problème algorithmique. En l'occurrence, la réponse est qu'il n'y a pas d'algorithme répondant au problème posé.

---

### L'époque contemporaine

- L’algorithmique des XXe et XXIe siècles a pour fondement mathématique des formalismes, par exemple celui des machines de Turing, qui permettent de définir précisément ce qu'on entend par "étapes", par "précis" et par "non ambigu" et qui donnent un cadre scientifique pour étudier les propriétés des algorithmes.

---

Cependant, suivant le formalisme choisi on obtient des approches algorithmiques différentes pour résoudre un même problème. Par exemple l'algorithmique récursive, l'algorithmique parallèle ou l’informatique quantique donnent lieu à des présentations d'algorithmes différentes de celles de l'algorithmique itérative.

---

Grâce à l'informatique, l'algorithmique s'est beaucoup développée dans la deuxième moitié du XXe siècle. Donald Knuth, auteur du traité The Art of Computer Programming, qui décrit de très nombreux algorithmes, a contribué, avec d'autres, à en poser les fondements mathématiques de leur analyse.

---

## L'algorithmique dans le projet

- Ecrit par l'etre humain, l'algorithme est traduit en instructions comprehensibles par l'ordinnateur. |
- Sa premiere fonction est d'etre comprise par un autre etre humain dans l'equipe de developpement. |
- “One of my most productive days was throwing away 1000 lines of code.” – Ken Thompson |

---
## Environnement de développement

- En programmation informatique, un environnement de développement est un ensemble d'outils pour augmenter la productivité des programmeurs qui développent des logiciels |
- Il comporte un éditeur de texte destiné à la programmation, des fonctions qui permettent, de démarrer le compilateur ou l'éditeur de liens ainsi qu'un débogueur en ligne, qui permet d'exécuter ligne par ligne le programme en cours de construction. |

---

- Certains environnements sont dédiés à un langage de programmation en particulier. Il ne faut pas hesiter a tout essayer pour voir ce qui permet d'arriver a ses fins le plus facilement. |
- Les outils qui assistent les développeurs dans toutes les étapes de la réalisation du logiciel: définition, conception, programmation, test et maintenance. |
- Ces outils tiennent également compte des différents rôles au sein d'une équipe de programmation

---

## Environnement de développement: éditeur de code

Toujours un éditeur de texte incorporé, avec souvent la possibilité de le remplacer par un autre éditeur. typiquement des fonctions de mise en évidence alignées avec le langage de programmation: indentation automatique des blocs de code, marquage des délimiteurs (parenthèses ou accolades), et mise en évidence des mots clés du langage par de la couleur ou des caractères gras

---
## Environnement de développement: création d'interface graphique

Un tel outil permet au programmeur de gagner un temps significatif dans la construction de l'interface graphique de son programme. Jusqu'à l'arrivée de la technologie Java, de tels outils ciblaient toujours un système d'exploitation en particulier.

---
## Environnement de développement: automatisation des tests

- outil pour réaliser automatiquement des tests |
- car le meilleur moyen de vérifier un algorithme complexe est souvent de créer un deuxième algorithme pour testr le premier |
- a noter la méthode "Test Driven Development" qui fait partie de l'"eXtrem Programing", propose d'écrire carrément un algorithme de validation avant d'écrire l'algorithme lui-même |

---

## Environnement de développement: languages

- Java: compile le code source en bytecode pour la JVM |
- C++: compile le code source en language machine |
- Visual Basic, Python, PHP: interprétés |

---

# Principe d'une machine à état

- Un automate fini est une construction mathématique abstraite, |
- susceptible d'être dans un nombre fini d'états, |
- mais étant un moment donné dans un seul état à la fois ; |
- l'état dans lequel il se trouve alors est appelé l'« état courant ». |
- Le passage d'un état à un autre est activé par un événement ou une condition ; |
- ce passage est appelé une « transition ».

---

# Exemples de machines à état

- distributeur automatique de boisson,
- portillon,
- ascenseurs,
- digicodes,
- citez des machines à état |

---

Un automate particulier est défini par l'ensemble de ses états et l'ensemble de ses transitions.

Vus comme un modèle de calcul les automates finis ont un potentiel faible ; ils ont bien moins de puissance de calcul qu'une machine de Turing. En d'autres termes, il y a des tâches qu'un automate fini ne peut pas accomplir alors qu'un automate à pile ou une machine de Turing le pourront. Ceci est principalement dû au fait qu'un automate fini a une mémoire limitée à son nombre d'états.

---

# Machine de Turing

- En informatique théorique, une machine de Turing est un modèle abstrait du fonctionnement des appareils mécaniques de calcul, tel un ordinateur et sa mémoire.
- Ce modèle a été imaginé par Alan Turing en 1936, en vue de donner une définition précise au concept d’algorithme ou de « procédure mécanique » |
- Il est toujours largement utilisé en informatique théorique, en particulier dans les domaines de la complexité algorithmique et de la calculabilité.

---

# Définition

- un alphabet fini,
- un ruban infini,
- une tête de lecture/écriture,
- un ensemble fini d'états,
- une table d'actions,

---

# Alphabet fini

L'alphabet contient un symbole spécial appelé « symbole blanc » et un ou plusieurs autres symboles.
On peut toujours encoder un symbole de l'alphabet en une suite de 1 et de 0, par example sur deux bits pour trois caractères:

| A | 00 |
| B | 01 |
| C | 11 |

Sur un ruban de 0 et de 1 on peut donc décider d'encoder des symboles d'alphabets de plus grandes tailles. Par exemple, UTF-8 utilise 8 bits par symbole et contient la pluparts des symboles d'alphabets utilisés par les humains. Cela consomme simplement plus d'espace que pour trois caractères.

---

# Ruban infini

Le ruban infini est divisé en cases consécutives.
Chaque case contient un symbole parmi un alphabet fini.
Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite
Donc la machine doit toujours avoir assez de longueur de ruban pour son exécution.
On considère que les cases non encore écrites du ruban contiennent le symbole « blanc »

---

# Registre d'état

Le registre d'état mémorise l'état courant de la machine de Turing.
Le nombre d'états possibles est toujours fini, et il existe un état spécial appelé « état de départ » qui est l'état initial de la machine avant son exécution ;

---

# Table d'actions / transitions

La table d'actions indique à la machine:

- quel symbole écrire sur le ruban,
- dans quel sens déplacer la tête de lecture,
- quel est le nouvel état,

En fonction:

- de l'état courant de la machine,
- du symbole lu sur le ruban par la tête de lecture,

Si aucune action n'existe pour une combinaison donnée d'un symbole lu et d'un état courant, la machine s'arrête.

---

# Tête de lecture / écriture

La tête de lecture/écriture peut lire et écrire les symboles sur le ruban, et se déplacer vers la gauche ou vers la droite du ruban.

À chaque étape de son calcul, la machine execute l'action correspondante à son actuel et au symbole lu par la tête de lecture. L'action correspond soit à l'arrêt de la machine, soit à l'écriture d'un symbole sous la tête de lecture, du déplacement de la tête de lecture du coté défini par l'action, et du changement d'état défini par l'action.

---

# Résumé

Quoique son nom de « machine » puisse conduire à croire le contraire, une machine de Turing est un concept abstrait, c'est-à-dire un objet mathématique comportant :

- un ruban infini de symboles de l'alphabet
- une tête de lecture/écriture qui peut lire et écrire les symboles sur le ruban,
- et se déplacer vers la gauche ou vers la droite du ruban
- un registre d'état qui mémorise l'état courant de la machine de Turing
- une table d'actions qui indique à la machine quel symbole écrire sur le ruban, comment déplacer la tête de lecture (par exemple « G » pour une case vers la gauche, « D » pour une case vers la droite), et quel est le nouvel état, en fonction du symbole lu sur le ruban et de l'état courant de la machine.

Si aucune action n'existe pour une combinaison donnée d'un symbole lu et d'un état courant, la machine s'arrête.

Le nombre d'états possibles est toujours fini, et il existe un état spécial appelé « état de départ » qui est l'état initial de la machine avant son exécution ;

- Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite, en d'autres termes la machine doit toujours avoir assez de longueur de ruban pour son exécution. On considère que les cases non encore écrites du ruban contiennent le symbole « blanc » ;

La machine de Turing lit un ruban et écrit le résultat dessus.

---

# Universalité de Turing

Comme Alan Turing le montre dans son article fondateur, il est possible de créer une machine de Turing qu'on appelle « machine de Turing universelle » et qui est capable de « simuler » le comportement de n'importe quelle autre machine de Turing. « Simuler » signifie que si la machine de Turing universelle reçoit en entrée un codage d'une machine et des données, et produit le même résultat que la machine codée à laquelle on donnerait en entrée les mêmes données.

---

# Turing-complete

Une machine de Turing universelle a potentiellement la capacité de calculer tout ce qui est calculable, on dit alors qu'elle est Turing-complète. En lui fournissant le codage adéquat, elle peut simuler toute fonction récursive, analyser tout langage récursif, et accepter tout langage partiellement décidable. Selon la thèse de Church-Turing, les problèmes résolubles par une machine de Turing universelle sont exactement les problèmes résolubles par un algorithme ou par une méthode concrète de calcul.

---

# Simulation de machine de Turing

Il est assez aisé de simuler une machine de Turing sur un ordinateur moderne, mais il y a une contrainte ! En effet alors que la mémoire d'un ordinateur est finie celle d'une machine de Turing est infinie. Ainsi la machine de Turing n'engendrera pas de débordement mémoire tandis qu'un ordinateur pourra le faire.

On peut observer une machine de turing en python avec debugger.

---

# Les variables : définition

- En mathématiques et en logique, une variable marque un rôle dans une formule, un prédicat ou un algorithme.
- En physique, en biologie, en mécanique et en chimie, la variable représente un paramètre mesurable comme la température, le temps, la vitesse ou l'intensité.
- En informatique, une variable est un symbole (habituellement un nom) qui renvoie à une position de mémoire dont le contenu peut prendre successivement différentes valeurs pendant l'exécution d'un programme.

---

# Les variables en informatique

En informatique, les variables sont des symboles qui associent un nom (l'identifiant) à une valeur. La valeur peut être de quelque type de donnée que ce soit. Le nom doit être un identifiant unique (et si le langage en possède, différents des mots-réservés).

---

Dans la plupart des langages et notamment les plus courants, les variables peuvent changer de valeur au cours du temps (dynamique). Dans les langages de certains paradigmes, notamment la programmation fonctionnelle, leur valeur est au contraire figée dans le temps (statique).

---

# Variables et constantes

Dans un langage de programmation, une variable est un espace de stockage pour un résultat. Cependant les possibilités d'une variable sont intimement liées au langage de programmation auquel on fait référence.

Une constante est un symbole associé à une valeur fixe. Syntaxiquement, cet identificateur a tous les aspects d'une variable. Cependant, il lui est affecté une valeur définie, c'est-à-dire constante, comme la taille d'un plateau d'échecs (8x8).

---

# Variables: cycle de vie

Une variable contient une valeur qui peut avoir différent valeurs au cours de différentes exécutions, comme un jeu tel que démineur joué sur un plateau dont le joueur choisit la taille.

Pour chaque constante et variable du programme, l'ordinateur réserve une partie de sa mémoire (RAM), de taille adéquate au type de données.

---

# Variable C++

Par exemple une variable en C++ aura six caractéristiques :

- nom
- type
- valeur
- adresse
- portée
- visibilité
- durée de vie

---

# Nom de variable

Dans certains langages, les noms de variables (comme ceux des identificateurs) doivent nécessairement commencer par une lettre (majuscule ou minuscule) ou par un $. Les autres caractères composant le nom de la variable doivent être une lettre, un chiffre. La différenciation des majuscules et des minuscules (sensibilité à la casse) dans le nom d'une variable dépend du langage considéré.

Exemples de noms de variables valides, en C :

    _var
    __var2
    Var

Exemple de nom de variable non valide en C :

    2var

---

# Nom de variable: enjeux

Mieux on choisit les noms de variables


- son nom c'est-à-dire sous quel nom est déclarée la variable ; |
- son type, c'est la convention d'interprétation de la séquence de bits qui constitue la variable. Le type de la variable spécifie aussi la longueur de cette séquence (8 bits, 32 bits, 64 bits) ; |
- sa valeur, c'est la séquence de bits elle-même, elle ne peut varier au cours du temps si on utilise le mot-clef const ; |
- son adresse, c'est l'endroit dans la mémoire où elle est stockée ; |
- sa portée, c'est la portion de code source où elle est accessible, par exemple, la portée d'une variable (non globale) en C s'entend de sa définition à la fin du bloc où elle est définie. |
- sa visibilité, c'est un ensemble de règles qui fixe qui peut utiliser la variable (exemple : mots-clefs public, private, protected, ou le masquage d'une variable par une autre) ; |
- sa durée de vie, c'est le temps d'exécution pendant laquelle la variable existe. En C et en C++ une variable contenue dans un bloc de code limité par des accolades "{}" possède la durée de vie correspondant au temps d'exécution de ce bloc. Il ne faut pas confondre la durée de vie d'une variable locale et sa visibilité, ou sa portée : une variable hors de portée (ex : masquée par une autre), existe toujours. |


---

### Heuristiques

Pour certains problèmes, les algorithmes ont une complexité beaucoup trop grande pour obtenir un résultat en temps raisonnable, même si l’on pouvait utiliser une puissance de calcul phénoménale.

---

### Complexité d'un algorithme

l'étude formelle de la quantité de ressources (par exemple de temps ou
d'espace) nécessaire à l'exécution de cet algorithme

C.A.R. Hoare, The 1980 ACM Turing Award Lecture:
> Il y a deux manières de construire une architecture logicielle: l'une est de la faire tellement simple qu'il n'y a évidemment aucune faille, l'autre est de la faire tellement compliquée qu'il n'y a aucune faille évidente

---

### Recherche de pic sur liste a une dimention

| a | b | c | d | e | f | g | h | i |
| - | - | - | - | - | - | - | - | - |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

- 2 est le pic si et seulement si b >= a and b >= b |
- 9 est le pic si et seulement si i >= h |
- problème: trouver un pic si possible |
- est-ce-qu'un pic existe obligatoirement ? |

---

### Recherche linéaire

| 1 | 2 |   |   | n/2 |   |   | n-1 | n |
| - | - | - | - | -   | - | - | -   | - |
| . | . | . | . |  .  | . | . |  .  | . |


- Parcourir la liste de gauche a droite jusqu'à trouver le pic. |
- Le meilleur des cas est celui où le pic est le premier dans la liste, le pic est alors trouvé instantanément. |
- Le pire des cas est celui où le pic est le dernier dans la liste, le pic est alors trouvé après avoir parcouru toute la liste |

---
### Recherche linéaire: complexté

- Si la liste contient 30 000 items, le pire cas demandera 30 000 étapes.
- La complexité dans le pire des cas de cette première méthode pour n entrées dans l'annuaire fourni est O(n), ça veut dire que dans le pire des cas, le temps de calcul est de l'ordre de grandeur de n : il faut parcourir tous les n items une fois |

---

### Comment optimiser l'algorithme ?

---
### Recherche dichotomique : diviser et concquerir

Ouvrir la liste au milieu, si le nombre qui s'y trouve est plus loin
que le max, regarder avant, sinon, regarder après.

Refaire l'opération qui consiste à couper les demi-annuaires (puis les quarts
d'annuaires, puis les huitièmes d'annuaires, etc.) jusqu'à trouver le nom
cherché.

---

---?image=assets/image/complexite-algorithmique.png

---
## Tips!

<br>

@fa[arrows gp-tip](Press F to go Fullscreen)

@fa[microphone gp-tip](Press S for Speaker Notes)

---?image=assets/image/kyle-gregory-devaras.jpg

## Template Features

- Code Presenting |
- Repo Source, Static Blocks, GIST |
- Custom CSS Styling |
- Slideshow Background Image |
- Slide-specific Background Images |
- Custom Logo, TOC, and Footnotes |

---?code=sample/go/server.go&lang=golang&title=Golang File

@[1,3-6](Present code found within any repo source file.)
@[8-18](Without ever leaving your slideshow.)
@[19-28](Using GitPitch code-presenting with (optional) annotations.)

---?image=assets/image/john-reign-abarintos.jpg

@title[JavaScript Block]

<p><span class="slide-title">JavaScript Block</span></p>

```javascript
// Include http module.
var http = require("http");

// Create the server. Function passed as parameter
// is called on every request made.
http.createServer(function (request, response) {
  // Attach listener on end event.  This event is
  // called when client sent, awaiting response.
  request.on("end", function () {
    // Write headers to the response.
    // HTTP 200 status, Content-Type text/plain.
    response.writeHead(200, {
      'Content-Type': 'text/plain'
    });
    // Send data and end response.
    response.end('Hello HTTP!');
  });

// Listen on the 8080 port.
}).listen(8080);
```

@[1,2](You can present code inlined within your slide markdown too.)
@[9-17](Displayed using code-syntax highlighting just like your IDE.)
@[19-20](Again, all of this without ever leaving your slideshow.)

---?gist=onetapbeyond/494e0fecaf0d6a2aa2acadfb8eb9d6e8&lang=scala&title=Scala GIST

@[23](You can even present code found within any GitHub GIST.)
@[41-53](GIST source code is beautifully rendered on any slide.)
@[57-62](And code-presenting works seamlessly for GIST too, both online and offline.)

---?image=assets/image/kyle-gregory-devaras.jpg

## Template Help

- [Code Presenting](https://github.com/gitpitch/gitpitch/wiki/Code-Presenting)
  + [Repo Source](https://github.com/gitpitch/gitpitch/wiki/Code-Delimiter-Slides), [Static Blocks](https://github.com/gitpitch/gitpitch/wiki/Code-Slides), [GIST](https://github.com/gitpitch/gitpitch/wiki/GIST-Slides)
- [Custom CSS Styling](https://github.com/gitpitch/gitpitch/wiki/Slideshow-Custom-CSS)
- [Slideshow Background Image](https://github.com/gitpitch/gitpitch/wiki/Background-Setting)
- [Slide-specific Background Images](https://github.com/gitpitch/gitpitch/wiki/Image-Slides#background)
- [Custom Logo](https://github.com/gitpitch/gitpitch/wiki/Logo-Setting), [TOC](https://github.com/gitpitch/gitpitch/wiki/Table-of-Contents), and [Footnotes](https://github.com/gitpitch/gitpitch/wiki/Footnote-Setting)

---?image=assets/image/kyle-gregory-devaras.jpg

## Go GitPitch Pro!

<br>
<div class="left">
    <i class="fa fa-user-secret fa-5x" aria-hidden="true"> </i><br>
    <a href="https://gitpitch.com/pro-features" class="pro-link">
    More details here.</a>
</div>
<div class="right">
    <ul>
        <li>Private Repos</li>
        <li>Private URLs</li>
        <li>Password-Protection</li>
        <li>Image Opacity</li>
        <li>SVG Image Support</li>
    </ul>
</div>

---?image=assets/image/kyle-gregory-devaras.jpg

### Questions?

<br>

@fa[twitter gp-contact](@gitpitch)

@fa[github gp-contact](gitpitch)

@fa[medium gp-contact](@gitpitch)

---?image=assets/image/gitpitch-audience.jpg

@title[Download this Template!]

### Get your presentation started!
### [Download this template @fa[external-link gp-download]](https://gitpitch.com/template/download/space)

# Formation Algorithmique

### Introduction
---
