# Algorithmie

![Glider](assets/image/Game_of_life_animated_glider.gif)

### Formation

---
## Principes generaux

- Un algorithme est une suite finie et non ambiguë d’opérations ou d'instructions permettant de résoudre un problème ou d'obtenir un résultat |
- Un problème est un objet mathématique qui représente une question ou un ensemble de questions auxquelles un ordinateur devrait être en mesure de répondre. |

---
- L'algorithmique est l'étude et la production de règles et techniques qui sont impliquées dans la définition et la conception d'algorithmes,
- c'est-à-dire de processus systématiques de résolution d'un problème permettant de décrire précisément des étapes pour résoudre un problème algorithmique. |
- Un algorithme prend des données en entrées et calcule des données en retour |

---

## Antiquité

- Les premiers algorithmes dont on a retrouvé des descriptions datent des Babyloniens, au IIIe millénaire av. J.-C.. Ils décrivent des méthodes de calcul et des résolutions d'équations à l'aide d'exemples. |
- Un algorithme célèbre est celui qui se trouve dans le livre 7 des Éléments d'Euclide, et appelé algorithme d'Euclide. Il permet de trouver le plus grand diviseur commun, ou PGCD, de deux nombres. |

---
C'est Archimède qui proposa le premier un algorithme pour le calcul de $$π^2$$

---
## Étude systématique

- Le premier à avoir systématisé des algorithmes est le mathématicien perse Al-Khwârizmî, actif entre 813 et 833. |
- Dans son ouvrage Abrégé du calcul par la restauration et la comparaison, il étudie toutes les équations du second degré et en donne la résolution par des algorithmes généraux. |

---

- Il utilise des méthodes semblables à celles des Babyloniens, mais se différencie par ses explications systématiques là où les Babyloniens donnaient seulement des exemples.
- Le mot algorithme vient du nom du mathématicien Al-Khwârizmî (latinisé au Moyen Âge en Algoritmi), qui, au IXe siècle écrivit le premier ouvrage systématique donnant des solutions aux équations linéaires et quadratiques. Algorithme a donné algorithmique auxquels certains préfèrent le néologisme algorithmie. |

---

Le savant andalou Averroès (1126-1198) évoque une méthode de raisonnement où la thèse s’affine étape par étape, itérativement, jusqu’à une certaine convergence et ceci conformément au déroulement d’un algorithme. À la même époque, au XIIe siècle, le moine Adelard de Bath introduit le terme latin de algorismus, par référence au nom de Al Khuwarizmi. Ce mot donne algorithme en français en 1554.

---

- Au XVIIe siècle, on pourrait entrevoir une certaine allusion à la méthode algorithmique chez René Descartes dans la méthode générale proposée par le Discours de la méthode (1637), notamment quand, en sa deuxième partie, le mathématicien français propose
- « diviser chacune des difficultés que j’examinerois, en autant de parcelles qu’il se pourroit, et qu’il seroit requis pour les mieux résoudre. » |

---
- Sans évoquer explicitement les concepts de boucle, d’itération ou de dichotomie, l’approche de Descartes prédispose la logique à accueillir le concept de programme, mot qui naît en français en 1677.
- En 1843 , la mathématicienne et pionnière des sciences informatique Ada Lovelace, fille de Lord Byron et assistante de Charles Babbage réalise la première implémentation d'un algorithme sous forme de programme (calcul des nombres de Bernoullii) |
---

Le dixième problème de Hilbert qui fait partie de la liste des 23 problèmes posés par David Hilbert en 1900 à Paris est clairement un problème algorithmique. En l'occurrence, la réponse est qu'il n'y a pas d'algorithme répondant au problème posé.

---

### L'époque contemporaine

- L’algorithmique des XXe et XXIe siècles a pour fondement mathématique des formalismes, par exemple celui des machines de Turing, qui permettent de définir précisément ce qu'on entend par "étapes", par "précis" et par "non ambigu" et qui donnent un cadre scientifique pour étudier les propriétés des algorithmes.

---

Cependant, suivant le formalisme choisi on obtient des approches algorithmiques différentes pour résoudre un même problème. Par exemple l'algorithmique récursive, l'algorithmique parallèle ou l’informatique quantique donnent lieu à des présentations d'algorithmes différentes de celles de l'algorithmique itérative.

---

Grâce à l'informatique, l'algorithmique s'est beaucoup développée dans la deuxième moitié du XXe siècle. Donald Knuth, auteur du traité The Art of Computer Programming, qui décrit de très nombreux algorithmes, a contribué, avec d'autres, à en poser les fondements mathématiques de leur analyse.

---

## L'algorithmique dans le projet

- Ecrit par l'etre humain, l'algorithme est traduit en instructions comprehensibles par l'ordinnateur. |
- Sa premiere fonction est d'etre comprise par un autre etre humain dans l'equipe de developpement. |
- “One of my most productive days was throwing away 1000 lines of code.” – Ken Thompson |

---
## Environnement de développement

- En programmation informatique, un environnement de développement est un ensemble d'outils pour augmenter la productivité des programmeurs qui développent des logiciels |
- Il comporte un éditeur de texte destiné à la programmation, des fonctions qui permettent, de démarrer le compilateur ou l'éditeur de liens ainsi qu'un débogueur en ligne, qui permet d'exécuter ligne par ligne le programme en cours de construction. |

---

- Certains environnements sont dédiés à un langage de programmation en particulier. Il ne faut pas hesiter a tout essayer pour voir ce qui permet d'arriver a ses fins le plus facilement. |
- Les outils qui assistent les développeurs dans toutes les étapes de la réalisation du logiciel: définition, conception, programmation, test et maintenance. |
- Ces outils tiennent également compte des différents rôles au sein d'une équipe de programmation

---

## Environnement de développement: éditeur de code

Toujours un éditeur de texte incorporé, avec souvent la possibilité de le remplacer par un autre éditeur. typiquement des fonctions de mise en évidence alignées avec le langage de programmation: indentation automatique des blocs de code, marquage des délimiteurs (parenthèses ou accolades), et mise en évidence des mots clés du langage par de la couleur ou des caractères gras

---
## Environnement de développement: création d'interface graphique

Un tel outil permet au programmeur de gagner un temps significatif dans la construction de l'interface graphique de son programme. Jusqu'à l'arrivée de la technologie Java, de tels outils ciblaient toujours un système d'exploitation en particulier.

---
## Environnement de développement: automatisation des tests

- outil pour réaliser automatiquement des tests |
- car le meilleur moyen de vérifier un algorithme complexe est souvent de créer un deuxième algorithme pour testr le premier |
- a noter la méthode "Test Driven Development" qui fait partie de l'"eXtrem Programing", propose d'écrire carrément un algorithme de validation avant d'écrire l'algorithme lui-même |

---

## Environnement de développement: languages

- Java: compile le code source en bytecode pour la JVM |
- C++: compile le code source en language machine |
- Visual Basic, Python, PHP: interprétés |

---

# Principe d'une machine à état

- Un automate fini est une construction mathématique abstraite, |
- susceptible d'être dans un nombre fini d'états, |
- mais étant un moment donné dans un seul état à la fois ; |
- l'état dans lequel il se trouve alors est appelé l'« état courant ». |
- Le passage d'un état à un autre est activé par un événement ou une condition ; |
- ce passage est appelé une « transition ».

---

# Exemples de machines à état

- distributeur automatique de boisson,
- portillon,
- ascenseurs,
- digicodes,
- citez des machines à état |

---

Un automate particulier est défini par l'ensemble de ses états et l'ensemble de ses transitions.

Vus comme un modèle de calcul les automates finis ont un potentiel faible ; ils ont bien moins de puissance de calcul qu'une machine de Turing. En d'autres termes, il y a des tâches qu'un automate fini ne peut pas accomplir alors qu'un automate à pile ou une machine de Turing le pourront. Ceci est principalement dû au fait qu'un automate fini a une mémoire limitée à son nombre d'états.

---

# Machine de Turing

- En informatique théorique, une machine de Turing est un modèle abstrait du fonctionnement des appareils mécaniques de calcul, tel un ordinateur et sa mémoire.
- Ce modèle a été imaginé par Alan Turing en 1936, en vue de donner une définition précise au concept d’algorithme ou de « procédure mécanique » |
- Il est toujours largement utilisé en informatique théorique, en particulier dans les domaines de la complexité algorithmique et de la calculabilité.

---

# Définition

- un alphabet fini,
- un ruban infini,
- une tête de lecture/écriture,
- un ensemble fini d'états,
- une table d'actions,

---

# Alphabet fini

L'alphabet contient un symbole spécial appelé « symbole blanc » et un ou plusieurs autres symboles.
On peut toujours encoder un symbole de l'alphabet en une suite de 1 et de 0, par example sur deux bits pour trois caractères:

| A | 00 |
| - | -- |
| B | 01 |
| C | 11 |

Sur un ruban de 0 et de 1 on peut donc décider d'encoder des symboles d'alphabets de plus grandes tailles. Par exemple, UTF-8 utilise 8 bits par symbole et contient la pluparts des symboles d'alphabets utilisés par les humains. Cela consomme simplement plus d'espace que pour trois caractères.

---

# Ruban infini

Le ruban infini est divisé en cases consécutives.
Chaque case contient un symbole parmi un alphabet fini.
Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite
Donc la machine doit toujours avoir assez de longueur de ruban pour son exécution.
On considère que les cases non encore écrites du ruban contiennent le symbole « blanc »

---

# Registre d'état

Le registre d'état mémorise l'état courant de la machine de Turing.
Le nombre d'états possibles est toujours fini, et il existe un état spécial appelé « état de départ » qui est l'état initial de la machine avant son exécution ;

---

# Table d'actions / transitions

La table d'actions indique à la machine:

- quel symbole écrire sur le ruban,
- dans quel sens déplacer la tête de lecture,
- quel est le nouvel état,

En fonction:

- de l'état courant de la machine,
- du symbole lu sur le ruban par la tête de lecture,

Si aucune action n'existe pour une combinaison donnée d'un symbole lu et d'un état courant, la machine s'arrête.

---

# Tête de lecture / écriture

La tête de lecture/écriture peut lire et écrire les symboles sur le ruban, et se déplacer vers la gauche ou vers la droite du ruban.

À chaque étape de son calcul, la machine execute l'action correspondante à son actuel et au symbole lu par la tête de lecture. L'action correspond soit à l'arrêt de la machine, soit à l'écriture d'un symbole sous la tête de lecture, du déplacement de la tête de lecture du coté défini par l'action, et du changement d'état défini par l'action.

---

# Résumé

Quoique son nom de « machine » puisse conduire à croire le contraire, une machine de Turing est un concept abstrait, c'est-à-dire un objet mathématique comportant :

- un ruban infini de symboles de l'alphabet
- une tête de lecture/écriture qui peut lire et écrire les symboles sur le ruban,
- et se déplacer vers la gauche ou vers la droite du ruban
- un registre d'état qui mémorise l'état courant de la machine de Turing
- une table d'actions qui indique à la machine quel symbole écrire sur le ruban, comment déplacer la tête de lecture (par exemple « G » pour une case vers la gauche, « D » pour une case vers la droite), et quel est le nouvel état, en fonction du symbole lu sur le ruban et de l'état courant de la machine.

Si aucune action n'existe pour une combinaison donnée d'un symbole lu et d'un état courant, la machine s'arrête.

Le nombre d'états possibles est toujours fini, et il existe un état spécial appelé « état de départ » qui est l'état initial de la machine avant son exécution ;

- Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite, en d'autres termes la machine doit toujours avoir assez de longueur de ruban pour son exécution. On considère que les cases non encore écrites du ruban contiennent le symbole « blanc » ;

La machine de Turing lit un ruban et écrit le résultat dessus.

---

# Universalité de Turing

Comme Alan Turing le montre dans son article fondateur, il est possible de créer une machine de Turing qu'on appelle « machine de Turing universelle » et qui est capable de « simuler » le comportement de n'importe quelle autre machine de Turing. « Simuler » signifie que si la machine de Turing universelle reçoit en entrée un codage d'une machine et des données, et produit le même résultat que la machine codée à laquelle on donnerait en entrée les mêmes données.

---

# Turing-complete

Une machine de Turing universelle a potentiellement la capacité de calculer tout ce qui est calculable, on dit alors qu'elle est Turing-complète. En lui fournissant le codage adéquat, elle peut simuler toute fonction récursive, analyser tout langage récursif, et accepter tout langage partiellement décidable. Selon la thèse de Church-Turing, les problèmes résolubles par une machine de Turing universelle sont exactement les problèmes résolubles par un algorithme ou par une méthode concrète de calcul.

---

# Simulation de machine de Turing

Il est assez aisé de simuler une machine de Turing sur un ordinateur moderne, mais il y a une contrainte ! En effet alors que la mémoire d'un ordinateur est finie celle d'une machine de Turing est infinie. Ainsi la machine de Turing n'engendrera pas de débordement mémoire tandis qu'un ordinateur pourra le faire.

On peut observer une machine de turing en python avec debugger.

---

# Les variables : définition

- En mathématiques et en logique, une variable marque un rôle dans une formule, un prédicat ou un algorithme.
- En physique, en biologie, en mécanique et en chimie, la variable représente un paramètre mesurable comme la température, le temps, la vitesse ou l'intensité.
- En informatique, une variable est un symbole (habituellement un nom) qui renvoie à une position de mémoire dont le contenu peut prendre successivement différentes valeurs pendant l'exécution d'un programme.

---

# Les variables en informatique

En informatique, les variables sont des symboles qui associent un nom (l'identifiant) à une valeur. La valeur peut être de quelque type de donnée que ce soit. Le nom doit être un identifiant unique (et si le langage en possède, différents des mots-réservés).

---

Dans la plupart des langages et notamment les plus courants, les variables peuvent changer de valeur au cours du temps (dynamique). Dans les langages de certains paradigmes, notamment la programmation fonctionnelle, leur valeur est au contraire figée dans le temps (statique).

---

# Variables et constantes

Dans un langage de programmation, une variable est un espace de stockage pour un résultat. Cependant les possibilités d'une variable sont intimement liées au langage de programmation auquel on fait référence.

Une constante est un symbole associé à une valeur fixe. Syntaxiquement, cet identificateur a tous les aspects d'une variable. Cependant, il lui est affecté une valeur définie, c'est-à-dire constante, comme la taille d'un plateau d'échecs (8x8).

---

# Variables: cycle de vie

Une variable contient une valeur qui peut avoir différent valeurs au cours de différentes exécutions, comme un jeu tel que démineur joué sur un plateau dont le joueur choisit la taille.

Pour chaque constante et variable du programme, l'ordinateur réserve une partie de sa mémoire (RAM), de taille adéquate au type de données.

---

# Variable C++

Par exemple une variable en C++ aura six caractéristiques :

- nom
- type
- valeur
- adresse
- portée
- visibilité
- durée de vie

---

# Nom de variable

Dans certains langages, les noms de variables (comme ceux des identificateurs) doivent nécessairement commencer par une lettre (majuscule ou minuscule) ou par un $. Les autres caractères composant le nom de la variable doivent être une lettre, un chiffre. La différenciation des majuscules et des minuscules (sensibilité à la casse) dans le nom d'une variable dépend du langage considéré.

Exemples de noms de variables valides, en C :

    _var
    __var2
    Var

Exemple de nom de variable non valide en C :

    2var

---


# Nom de variable: enjeux

Mieux on choisit les noms de variables, plus le code sera relisible. On remarque avec l'experience que ça vaut le coup de passer plus de temps, 10, 15 ou 20 minutes à choisir un nom de variable qu'on va utiliser pendant des années. Quand on peut trouver un nom de variable qui loge sur un nom simple c'est mieux.

En Python, il n’y a pas de déclaration de type. Le nom d’une variable a donc d’autant plus d’importance pour expliquer ce qu’il y a dedans.

---

Ainsi, le premier caractère ne peut être un chiffre, car cela permet de faciliter la compilation ou l'interprétation du programme en ôtant une ambiguïté : quand le compilateur lit un chiffre, il sait que les caractères qui suivront constitueront une valeur numérique. De même, s'il lit une lettre ou un souligné, il saura qu'il a affaire à une variable.

---

# Nom de variable: exemple

Est-ce-qu'on comprend ce que fait cet algorithme en Python ?

```python
best = []
for k, v in data.items():
    if v > top:
        best.append(k)
```

---

Est-ce-que c'est plus clair avec des noms explicites ?

```python
best_players = []
for player, score in data.items():
    if score > top_score :
        best_players.append(player)
```

---

# Typage

En programmation informatique, un type de donnée, ou simplement type, définit la nature des valeurs que peut prendre une donnée, ainsi que les opérateurs qui peuvent lui être appliqués.

---

# Examples de types prédéfinis

Tous les langages de programmation offrent des types de base correspondant aux données qui peuvent être traitées directement — à savoir : sans conversion ou formatage préalable — par le processeur. Ces types de base sont souvent :

- Type booléen : valeurs vrai ou faux — ou respectivement 1 ou 0 ;
- Type entier signé ou non signé : valeurs codées sur 8 bits, 16 bits, 32 bits voire 64 bits.
- Type réel en virgule flottante.

Les langages permettant un accès direct à la mémoire du système offrent par ailleurs le type pointeur, et un type octet.

Beaucoup proposent également un type prédéfini, string, pour les chaînes de caractères. Les langages de haut niveau peuvent également supporter nativement des types correspondant à d'autres structures de données.

---

# Types paramétrés

Par exemple la déclaration des pointeurs ou des tableaux en langage C nécessite de préciser le type qui doit servir de base aux données manipulées. La programmation générique étend cette pratique pour permettre à l'utilisateur de créer ses propres types paramétrés.

```java
Collection<String> coll = new LinkedList<String>();
```

---

# Types énumérés

Des langages permettent au développeur de définir des types spécifiques à son application. Les types énumérés correspondent à des ensembles « finis » (cf. les remarques ci-après) de valeurs possibles pour une variable. Le code suivant illustre la définition d'un nouveau type, suivie de la déclaration d'une variable typée :

```c
type couleur : {rouge, bleu, vert};
var c : couleur;  // La variable c, du type couleur, peut prendre les valeurs
	                // rouge, bleu ou vert uniquement.
```

---

# Types composés

Les types composés (struct en C, record en Pascal) permettent de grouper plusieurs champs de types distincts dans une même variable (qui contient alors des « sous-variables »).

En programmation orientée objet, on nomme classe un type composé associé à du code spécifique — la définition des méthodes de la classe — propre à la manipulation de variables de ce type.

---

# Types hiérarchiques

La programmation orientée objet étend le paradigme précédent en organisant hiérarchiquement les classes de telle manière qu'une variable d'une sous-classe puisse être utilisée de manière transparente à la place de n'importe quelle classe située à un niveau supérieur dans la hiérarchie définie.

---

# Types opaques

Un type opaque est un type incomplètement défini et/ou dont la nature est masquée. Le développeur ne peut ni en examiner le contenu, ni le modifier, et doit simplement le stocker et le transmettre. À cet effet, seule la taille d'un type opaque est réellement connue.

Typiquement, les données opaques sont des handles (terminologie Windows), des descripteurs de fichier (terminologie Unix), des clés, des pointeurs vers des structures masquées (ex. : `FILE*` de la bibliothèque standard du C), etc. La seule notion cruciale, c'est qu'une variable opaque est fournie via une fonction dédiée de création (de type constructeur), transmise telle quelle aux fonctions utilisatrices (souvent via un passage par référence), et enfin détruite via une fonction de libération (de type destructeur).

La possibilité – ou non – d'avoir des types opaques est totalement dépendante du langage de programmation utilisé.

---

# Résumé des types de données

- prédéfinis: booléan, entier (signé/non-signé), réel (virgule flottante), ... |
- paramétrés: types qui prennent d'autres type en paramêtre, |
- énumérés: ensembles « finis » de valeurs possibles, |
- composés: struct (C), record (Pascal), class (Python),
- hiérarchiques: sous classes
- opaques: descripteurs de fichiers, cléfs ...

---

# Typage statique et typage dynamique

On parle de typage statique quand la majorité des vérifications de type sont effectuées au moment de la compilation.

Au contraire, on parle de typage dynamique quand ces vérifications sont effectuées pendant l'exécution.

---

# Typage explicite et typage implicite

Le typage explicite oblige l'utilisateur à indiquer les types qu'il utilise, par exemple lors des déclarations de variables ou de fonctions.

Par exemple, en langage C, le typage est explicite :

```c
int i = 0;  // cette déclaration indique explicitement que
            // la variable i est de type entier
```

Au contraire, le typage implicite permet au developpeur de laisser le compilateur ou le runtime le soin de déterminer tout seul les types de données utilisées.

Par exemple, en Objective Caml, le typage est implicite :

```
let i = 0 ;; (* le compilateur détermine automatiquement que
                la variable i est de type entier *)
```

---

# Typage fort et typage faible

La sûreté du typage est destinée à prévenir les erreurs de type, à savoir : l'emploi d'une variable dont le format est incompatible. La définition d'un langage fortement typé est assez floue :

- soit elle est à rapprocher de celle de langage à typage statique : le compilateur assure la détection au plus tôt des erreurs de type
- soit on juge de la force du typage d'un langage selon les conversions de type implicites qu'il autorise.


---

# Adresse de variable

La mémoire RAM est composée de cellules. Chaque cellule a un numéro, c'est son **adresse**.

La mémoire comporte un grand nombre d'adresses, commençant à l'adresse numéro 0 et se terminant à l'adresse numéro (insérez un très grand nombre ici). Le nombre d'adresses disponibles dépend en fait de la quantité de mémoire dont dispose votre ordinateur.

---

# Valeur de variable

À chaque adresse, on peut stocker un nombre. Un et UN SEUL nombre. On ne peut pas stocker deux nombres par adresse.

Votre mémoire n'est faite que pour stocker des nombres. Elle ne peut stocker ni lettres ni phrases. Pour contourner ce problème, on a inventé une table qui fait la liaison entre les nombres et les lettres. Cette table dit par exemple : « Le nombre 89 représente la lettre Y ». Nous reviendrons dans un prochain chapitre sur la gestion des caractères ; pour l'instant, nous nous concentrons sur le fonctionnement de la mémoire.

---

# Portée de variable

Une portée lexicale est définie par une portion du code source. Au sein de cette portion, l'identifiant n'a qu'une seule liaison.

---

# Portée globale

Un identifiant à portée globale est lié dans l'ensemble du code source (parfois seulement après sa déclaration ou sa définition). Dans de nombreux langages de programmation, toutes les fonctions ont une portée globale (exemple : C).

---

# Portée locale

Un identifiant à portée locale n'est lié qu'au sein d'une construction syntaxique du langage, généralement celle où il est déclaré. Lorsqu'un identifiant à portée locale désigne une variable, on parle alors de variable locale. De plus, dans la plupart des langages, un identifiant à portée locale masque tout éventuel identifiant de même nom, mais de plus grande portée. Déclarer deux fois le même identifiant dans la même portée peut être considéré comme une erreur ou comme une redéclaration, selon le langage et le contexte.

---

# Visibilité de variable

`+`: accès public: Toutes les autres classes ont accès à cet attribut.
`#`: accès protégé: Seules la classe elle-même et les classes filles (héritage) ont accès à cet attribut.
`~`: accès package: Classe visible uniquement dans le package.
`-`: accès privé: Seule la classe elle-même a accès à cet attribut.

---

# Durée de vie de variable

On distingue généralement cinq opérations sur les variables, chacune pouvant revêtir des formes syntaxiques différentes.

- la déclaration permet de déclarer un nom de variable, éventuellement de lui associer un type,
- la définition permet d'associer une zone mémoire qui va être utilisée pour stocker la variable, comme lorsqu'on lui donne une valeur initiale,
- l'affectation consiste à attribuer une valeur à une variable,
- la lecture consiste à utiliser la valeur liée à la variable,
- la suppression réalisée soit automatiquement soit par une instruction du langage.

Dans les langages de programmation fonctionnelle ou de programmation logique, les variables ne peuvent être associées qu'à une seule valeur au cours de leur existence.

---

Les langages, comme le C, Caml ou Pascal, imposent de déclarer une variable voire de lui donner un type avant son usage. La déclaration imposée des variables permet au compilateur ou à l'interpréteur d'identifier les erreurs typographiques comme des variables non déclarées ou des variables homonymes. D'autres langages effectuent la déclaration au moment de la première affectation (c'est le cas de la plupart des langages de script) ou lors de leur première apparition dans le code (comme dans Prolog).

---

En ce qui concerne l'initialisation des variables, c'est-à-dire l'association d'une première valeur, certains langages imposent d'initialiser une variable avant sa première lecture alors que d'autres fournissent une valeur implicite (spécifiée ou indéterminée). Des langages comme Oz ou Prolog ne réalisent pas à proprement parler d'initialisation. Lors de la déclaration des variables aucune valeur n'est associée, on dit que la variable n'est pas liée. La valeur de la variable est déterminée au fur et à mesure de l'exécution du programme, on parle alors d'unification.

---

# Variables : Résumé

- **nom**: sous quel nom est déclarée la variable
- **type**: convention d'interprétation de la séquence de bits qui constitue la variable. Le type de la variable spécifie aussi la longueur de cette séquence (8 bits, 32 bits, 64 bits) |
- **valeur**, la séquence de bits elle-même, ne peut varier dans le cas d'une variable **constante** |
- **adresse**: l'endroit dans la mémoire où la valeur est stockée |
- **portée**: portion de code source où elle est accessible |
- **visibilité**: ensemble de règles fixant qui peut utiliser la variable (exemple : mots-clefs public, private, protected, ou le masquage d'une variable par une autre) |
- **durée de vie**: temps d'exécution pendant laquelle la variable existe. |

en C et en C++ une variable contenue dans un bloc de code limité par des accolades "{}" possède la durée de vie correspondant au temps d'exécution de ce bloc. Il ne faut pas confondre la durée de vie d'une variable locale et sa visibilité, ou sa portée : une variable hors de portée (ex : masquée par une autre), existe toujours. |

---

# Simplification

Toutefois on peut trouver des langages qui simplifient ces caractéristiques :

- la notion de variable est complétée par la notion de pointeur (variable qui contient une adresse) dans tous les langages qui permettent la création dynamique de variable (new en C++, Java); L'adresse contenu dans la variable pointeur peut être inaccessible au programmeur (PHP, Java), ou directement accessible (C++).
- le PHP ne possède pas un typage fort, comme une grande partie des langages scripts ;
- le Prolog ne permet pas qu'une variable change de valeur au cours du temps une fois la première identification faite ;
- la visibilité de la variable est public par défaut en C ;
- la notion de pointeur en C++ est remplacée par la notion de référence en Java, en Prolog l'adresse d'une variable n'est pas accessible au programmeur.

Typiquement, le but des langages dits de "scripting" est d'être plus faciles à manipuler pour résoudre des problèmes avec des algorithmes sur mesure.

---

# Structures de contrôles : les conditions

---

---

### Heuristiques

Pour certains problèmes, les algorithmes ont une complexité beaucoup trop grande pour obtenir un résultat en temps raisonnable, même si l’on pouvait utiliser une puissance de calcul phénoménale.

---

### Complexité d'un algorithme

l'étude formelle de la quantité de ressources (par exemple de temps ou
d'espace) nécessaire à l'exécution de cet algorithme

C.A.R. Hoare, The 1980 ACM Turing Award Lecture:
> Il y a deux manières de construire une architecture logicielle: l'une est de la faire tellement simple qu'il n'y a évidemment aucune faille, l'autre est de la faire tellement compliquée qu'il n'y a aucune faille évidente

---

### Recherche de pic sur liste a une dimention

| a | b | c | d | e | f | g | h | i |
| - | - | - | - | - | - | - | - | - |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

- 2 est le pic si et seulement si b >= a and b >= b |
- 9 est le pic si et seulement si i >= h |
- problème: trouver un pic si possible |
- est-ce-qu'un pic existe obligatoirement ? |

---

### Recherche linéaire

| 1 | 2 |   |   | n/2 |   |   | n-1 | n |
| - | - | - | - | -   | - | - | -   | - |
| . | . | . | . |  .  | . | . |  .  | . |


- Parcourir la liste de gauche a droite jusqu'à trouver le pic. |
- Le meilleur des cas est celui où le pic est le premier dans la liste, le pic est alors trouvé instantanément. |
- Le pire des cas est celui où le pic est le dernier dans la liste, le pic est alors trouvé après avoir parcouru toute la liste |

---
### Recherche linéaire: complexté

- Si la liste contient 30 000 items, le pire cas demandera 30 000 étapes.
- La complexité dans le pire des cas de cette première méthode pour n entrées dans l'annuaire fourni est O(n), ça veut dire que dans le pire des cas, le temps de calcul est de l'ordre de grandeur de n : il faut parcourir tous les n items une fois |

---

### Comment optimiser l'algorithme ?

---
### Recherche dichotomique : diviser et concquerir

Ouvrir la liste au milieu, si le nombre qui s'y trouve est plus loin
que le max, regarder avant, sinon, regarder après.

Refaire l'opération qui consiste à couper les demi-annuaires (puis les quarts
d'annuaires, puis les huitièmes d'annuaires, etc.) jusqu'à trouver le nom
cherché.

---

---?image=assets/image/complexite-algorithmique.png

---
## Tips!

<br>

@fa[arrows gp-tip](Press F to go Fullscreen)

@fa[microphone gp-tip](Press S for Speaker Notes)

---?image=assets/image/kyle-gregory-devaras.jpg

## Template Features

- Code Presenting |
- Repo Source, Static Blocks, GIST |
- Custom CSS Styling |
- Slideshow Background Image |
- Slide-specific Background Images |
- Custom Logo, TOC, and Footnotes |

---?code=sample/go/server.go&lang=golang&title=Golang File

@[1,3-6](Present code found within any repo source file.)
@[8-18](Without ever leaving your slideshow.)
@[19-28](Using GitPitch code-presenting with (optional) annotations.)

---?image=assets/image/john-reign-abarintos.jpg

@title[JavaScript Block]

<p><span class="slide-title">JavaScript Block</span></p>

```javascript
// Include http module.
var http = require("http");

// Create the server. Function passed as parameter
// is called on every request made.
http.createServer(function (request, response) {
  // Attach listener on end event.  This event is
  // called when client sent, awaiting response.
  request.on("end", function () {
    // Write headers to the response.
    // HTTP 200 status, Content-Type text/plain.
    response.writeHead(200, {
      'Content-Type': 'text/plain'
    });
    // Send data and end response.
    response.end('Hello HTTP!');
  });

// Listen on the 8080 port.
}).listen(8080);
```

@[1,2](You can present code inlined within your slide markdown too.)
@[9-17](Displayed using code-syntax highlighting just like your IDE.)
@[19-20](Again, all of this without ever leaving your slideshow.)

---?gist=onetapbeyond/494e0fecaf0d6a2aa2acadfb8eb9d6e8&lang=scala&title=Scala GIST

@[23](You can even present code found within any GitHub GIST.)
@[41-53](GIST source code is beautifully rendered on any slide.)
@[57-62](And code-presenting works seamlessly for GIST too, both online and offline.)

---?image=assets/image/kyle-gregory-devaras.jpg

## Template Help

- [Code Presenting](https://github.com/gitpitch/gitpitch/wiki/Code-Presenting)
  + [Repo Source](https://github.com/gitpitch/gitpitch/wiki/Code-Delimiter-Slides), [Static Blocks](https://github.com/gitpitch/gitpitch/wiki/Code-Slides), [GIST](https://github.com/gitpitch/gitpitch/wiki/GIST-Slides)
- [Custom CSS Styling](https://github.com/gitpitch/gitpitch/wiki/Slideshow-Custom-CSS)
- [Slideshow Background Image](https://github.com/gitpitch/gitpitch/wiki/Background-Setting)
- [Slide-specific Background Images](https://github.com/gitpitch/gitpitch/wiki/Image-Slides#background)
- [Custom Logo](https://github.com/gitpitch/gitpitch/wiki/Logo-Setting), [TOC](https://github.com/gitpitch/gitpitch/wiki/Table-of-Contents), and [Footnotes](https://github.com/gitpitch/gitpitch/wiki/Footnote-Setting)

---?image=assets/image/kyle-gregory-devaras.jpg

## Go GitPitch Pro!

<br>
<div class="left">
    <i class="fa fa-user-secret fa-5x" aria-hidden="true"> </i><br>
    <a href="https://gitpitch.com/pro-features" class="pro-link">
    More details here.</a>
</div>
<div class="right">
    <ul>
        <li>Private Repos</li>
        <li>Private URLs</li>
        <li>Password-Protection</li>
        <li>Image Opacity</li>
        <li>SVG Image Support</li>
    </ul>
</div>

---?image=assets/image/kyle-gregory-devaras.jpg

### Questions?

<br>

@fa[twitter gp-contact](@gitpitch)

@fa[github gp-contact](gitpitch)

@fa[medium gp-contact](@gitpitch)

---?image=assets/image/gitpitch-audience.jpg

@title[Download this Template!]

---

### Credits

Remerciements aux créateurs de contenus qui m'ont aidé à faire cette présentation:

- Wikipedia
- [Cours du MIT sur les algorithmes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/)
- [Cours du MIT sur les mathématiques pour l'inforhmatique](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/)
- [Sam & Max](http://sametmax.com/) pour l'exemple sur les noms de variables

### Get your presentation started!
### [Download this template @fa[external-link gp-download]](https://gitpitch.com/template/download/space)

# Formation Algorithmique

### Introduction
---
